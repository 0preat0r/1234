from copy import deepcopy

from cached_property import cached_property

from module.base.timer import timer
from module.config.utils import *
from module.logger import logger

CONFIG_IMPORT = '''
import datetime

# This file was automatically generated by module/config/db.py.
# Don't modify it manually.


class GeneratedConfig:
    """
    Auto generated configuration
    """
'''.strip().split('\n')


class ConfigGenerator:
    @cached_property
    def argument(self):
        """
        Load argument.yaml, and standardise its structure.

        <group>:
            <argument>:
                type: checkbox|select|textarea|input
                value:
                option: Options, if argument has any options.
        """
        data = {}
        raw = read_file(filepath_argument('argument'))
        for path, value in deep_iter(raw, depth=2):
            arg = {
                'type': 'input',
                'value': '',
                # option
            }
            if not isinstance(value, dict):
                value = {'value': value}
            arg['type'] = data_to_type(value, arg=path[1])
            arg.update(value)
            deep_set(data, keys=path, value=arg)

        return data

    @cached_property
    def task(self):
        """
        <task>:
            - <group>
        """
        return read_file(filepath_argument('task'))

    @cached_property
    def override(self):
        """
        <task>:
            <group>:
                <argument>: value
        """
        return read_file(filepath_argument('override'))

    @cached_property
    @timer
    def args(self):
        """
        Merge definitions into standardised json.

            task.yaml ---+
        argument.yaml ---+-----> args.json
        override.yaml ---+

        """
        # Construct args
        data = {}
        for task, groups in self.task.items():
            for group in groups:
                if group not in self.argument:
                    logger.warning(f'`{task}.{group}` is not related to any argument group')
                    continue
                deep_set(data, keys=[task, group], value=deepcopy(self.argument[group]))

        # Override non-modifiable arguments
        for path, value in deep_iter(self.override, depth=3):
            # Check existence
            old = deep_get(data, keys=path, default=None)
            if old is None:
                logger.warning(f'`{".".join(path)}` is not a existing argument')
                continue
            # Check type
            old_value = old.get('value', None) if isinstance(old, dict) else old
            if type(value) != type(old_value):
                logger.warning(
                    f'`{value}` ({type(value)}) and `{".".join(path)}` ({type(old_value)}) are in different types')
                continue
            # Check option
            if isinstance(old, dict) and 'option' in old:
                if value not in old['option']:
                    logger.warning(f'`{value}` is not an option of argument `{".".join(path)}`')
                    continue

            deep_set(data, keys=path + ['value'], value=value)
            deep_set(data, keys=path + ['type'], value='disable')

        # Set command
        for task in self.task.keys():
            deep_set(data, keys=f'{task}.Scheduler.Command.value', value=task)
            deep_set(data, keys=f'{task}.Scheduler.Command.type', value='disable')

        write_file(filepath_args(), data)
        return data

    @timer
    def generate_code(self):
        """
        Generate python code.

        args.json ---> config_generated.py

        """
        visited_group = set()
        visited_path = set()
        lines = CONFIG_IMPORT
        for path, data in deep_iter(self.argument, depth=2):
            group, arg = path
            if group not in visited_group:
                lines.append('')
                lines.append(f'    # Group `{group}`')
                visited_group.add(group)

            option = ''
            if 'option' in data and data['option']:
                option = '  # ' + ', '.join([str(opt) for opt in data['option']])
            path = '.'.join(path)
            lines.append(f'    {path_to_arg(path)} = {repr(parse_value(data["value"], data=data))}{option}')
            visited_path.add(path)

        with open(filepath_code(), 'w') as f:
            for text in lines:
                f.write(text + '\n')

    @timer
    def generate_i18n(self, lang):
        """
        Load old translations and generate new translation file.

                     args.json ---+-----> i18n/<lang>.json
        (old) i18n/<lang>.json ---+

        """
        new = {}
        old = read_file(filepath_i18n(lang))
        visited_group = set()

        def deep_load(keys, default=None):
            if default is None:
                default = ".".join(keys)
            value = deep_get(old, keys=keys, default=default)
            deep_set(new, keys=keys, value=value)

        for func in self.args.keys():
            for word in ['name', 'help']:
                deep_load(['_menu', func, word])

        for path, data in deep_iter(self.argument, depth=2):
            if path[0] not in visited_group:
                for word in ['name', 'help']:
                    deep_load([path[0], '_info', word])
                visited_group.add(path[0])
            for word in ['name', 'help']:
                deep_load(path + [word])
            if 'option' in data:
                for word in data['option']:
                    deep_load(path + [word], default=str(word))

        write_file(filepath_i18n(lang), new)

    @timer
    def generate(self):
        _ = self.args
        self.generate_code()
        for lang in LANGUAGES:
            self.generate_i18n(lang)


class ConfigUpdater:
    @cached_property
    def args(self):
        return read_file(filepath_args())

    def read_file(self, config_name):
        """
        Read and update user config.

        Args:
            config_name (str):

        Returns:
            dict:
        """
        new = {}
        old = read_file(filepath_config(config_name))

        def deep_load(keys):
            data = deep_get(self.args, keys=keys, default={})
            value = deep_get(old, keys=keys, default=data['value'])
            if value is None or data['type'] == 'disable':
                value = data['value']
            value = parse_value(value, data=data)
            deep_set(new, keys=keys, value=value)

        for path, _ in deep_iter(self.args, depth=3):
            deep_load(path)

        if config_name =='template':
            deep_set(new, 'Alas.DropRecord.AzurStatsID', None)
        else:
            deep_default(new, 'Alas.DropRecord.AzurStatsID', random_id())

        return new

    @timer
    def update_config(self, config_name):
        write_file(filepath_config(config_name), self.read_file(config_name))


if __name__ == '__main__':
    """
    Process the whole config generation.
    
                 task.yaml -+              +-> For GUI generation
             argument.yaml -+-> args.json -+-> config_generated.py
             override.yaml -+       |
                                    |
    (old) i18n/<lang>.json ---------\========> i18n/<lang>.json
    (old)    template.json ---------\========> template.json
    """
    ConfigGenerator().generate()
    ConfigUpdater().update_config('template')
